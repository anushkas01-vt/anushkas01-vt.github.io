<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Anushka S">
<meta name="dcterms.date" content="2023-12-03">

<title>CS5805 - Probability Theory</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">CS5805</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://linkedin.com" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">Probability Theory</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
                                <div class="quarto-categories">
                <div class="quarto-category">Probability Theory</div>
                <div class="quarto-category">Machine Learning</div>
                <div class="quarto-category">Random Variables</div>
                <div class="quarto-category">Hidden Markov Models</div>
                <div class="quarto-category">Viterbi algorithm</div>
                <div class="quarto-category">Baum Welch</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Anushka S </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 3, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Hidden Markov Models (HMMs) are a powerful statistical tool used in various fields, including speech recognition, bioinformatics, and natural language processing. Grounded in probability theory, HMMs are a type of stochastic model that represents a system evolving over time with hidden states. The model assumes that the observed data result from a probabilistic process involving these hidden states, making it particularly effective in situations where the underlying dynamics are not directly observable but can be inferred through observed data and the probabilities governing state transitions and emissions. Probability theory forms the backbone of HMMs, allowing them to make predictions and decisions based on the likelihood of sequences of observations given the modelâ€™s parameters.</p>
<div class="cell" data-execution_count="1">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The [hmmlearn] library in Python performs Unsupervised learning and inference of Hidden Markov Models.</p>
<p>Let us take the common Hidden Markov Model example of the ocassionally dishonest casino. In a casino, they use a fair die most of the time, but switch to the loaded die once in a while. The purpose of making use of the Hidden Markov Model is to identify instances when the dice roll is probabilistically from the fair die or the loaded die.</p>
<p>The probabilities for the various outcome variables have been adapted from <a href="https://doi.org/10.1017/CBO9780511790492">this textbook</a>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="dice_prob.JPG" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption class="figure-caption">Markov Model for dishonest casino</figcaption>
</figure>
</div>
<p>The emission probabilities are the probability of each outcome (die roll) at its current state. The transition probabilities define the probability of transitioning to a state (fair, loaded), and the start probabilities define the starting probability of being in each state.</p>
<p>From the hmmlearn library, the CategoricalHMM model (derived from the MultinomialHMM model), uses the Baum-Welch algorithm for training hidden Markov models (HMMs). The Baum-Welch algorithm, also known as the Forward-Backward algorithm or the Expectation-Maximization (EM) algorithm for HMMs, is an iterative procedure for estimating the parameters of an HMM given a set of observed data.</p>
<p>You can read more on the training of the Hidden Markov Model and the probability theory behind identifying the sequence state part at the end of this blog.</p>
<p>In the block of code below, we initialize the probabilities, initialize the CategoricalHMM method which takes in n_components as the number of possible states, the number of iterations for training. The other parameters (such as init_param, algorithm, etc.) details can be found <a href="https://hmmlearn.readthedocs.io/en/latest/api.html#categoricalhmm">here</a>.</p>
<p>We then use the sample() method to generate die roll and corresponding state samples.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">from</span> hmmlearn <span class="im">import</span> hmm</span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a>gen_model <span class="op">=</span> hmm.CategoricalHMM(n_components<span class="op">=</span><span class="dv">2</span>, n_iter<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a>gen_model.startprob_ <span class="op">=</span> np.array([<span class="fl">1.0</span>, <span class="fl">0.0</span>])</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a>gen_model.transmat_ <span class="op">=</span> np.array([[<span class="fl">0.95</span>, <span class="fl">0.05</span>],</span>
<span id="cb2-8"><a href="#cb2-8"></a>                                [<span class="fl">0.1</span>, <span class="fl">0.9</span>]])</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a>gen_model.emissionprob_ <span class="op">=</span> <span class="op">\</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    np.array([[<span class="dv">1</span> <span class="op">/</span> <span class="dv">6</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">6</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">6</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">6</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">6</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">6</span>],</span>
<span id="cb2-12"><a href="#cb2-12"></a>              [<span class="dv">1</span> <span class="op">/</span> <span class="dv">10</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">10</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">10</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">10</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">10</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">2</span>]])</span>
<span id="cb2-13"><a href="#cb2-13"></a></span>
<span id="cb2-14"><a href="#cb2-14"></a>rolls, gen_states <span class="op">=</span> gen_model.sample(<span class="dv">30000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="3">
<div class="cell-output cell-output-stdout">
<pre><code>Transition Model:
Emission Matrix:</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Probability_files/figure-html/cell-4-output-2.png" width="466" height="463"></p>
</div>
<div class="cell-output cell-output-display" data-execution_count="3">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Fair</th>
<th data-quarto-table-cell-role="th">Unfair</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">1</td>
<td>0.166667</td>
<td>0.1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2</td>
<td>0.166667</td>
<td>0.1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">3</td>
<td>0.166667</td>
<td>0.1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">4</td>
<td>0.166667</td>
<td>0.1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">5</td>
<td>0.166667</td>
<td>0.1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="cell" data-execution_count="4">
<div class="cell-output cell-output-stdout">
<pre><code>Sample of Dice Rolls generated</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="4">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Roll</th>
<th data-quarto-table-cell-role="th">Coin_State</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>4</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>3</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Plotting the states of the first 500 generated coin flips:</p>
<div class="cell" data-execution_count="5">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>ax.plot(gen_states[:<span class="dv">500</span>])</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'States over time'</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Time (# of rolls)'</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'State'</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>fig.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\Anu2001\AppData\Local\Temp\ipykernel_2396\1192688859.py:6: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Probability_files/figure-html/cell-6-output-2.png" width="589" height="449"></p>
</div>
</div>
<p>Plotting the rolls for the fair and loaded states</p>
<div class="cell" data-execution_count="6">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>ax.hist(rolls[gen_states <span class="op">==</span> <span class="dv">0</span>], label<span class="op">=</span><span class="st">'fair'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        bins<span class="op">=</span>np.arange(<span class="dv">7</span>) <span class="op">-</span> <span class="fl">0.5</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>ax.hist(rolls[gen_states <span class="op">==</span> <span class="dv">1</span>], label<span class="op">=</span><span class="st">'loaded'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        bins<span class="op">=</span>np.arange(<span class="dv">7</span>) <span class="op">-</span> <span class="fl">0.5</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Roll probabilities by state'</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Count'</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Roll'</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>fig.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\Anu2001\AppData\Local\Temp\ipykernel_2396\1259329272.py:10: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Probability_files/figure-html/cell-7-output-2.png" width="589" height="449"></p>
</div>
</div>
<p>In the code below, we are performing a 50%-50% train-test dataset split. We are then fitting the model on our train set and obtaining the score for the model which is simply the log probability under the model. Then, we make use of the predict method which implements the Viterbi algorithm to predict the best sequence of states for the given observations (dice rolls).</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># split our data into training and validation sets (50/50 split)</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>X_train <span class="op">=</span> rolls[:rolls.shape[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span>]</span>
<span id="cb9-3"><a href="#cb9-3"></a>X_test <span class="op">=</span> rolls[rolls.shape[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span>:]</span>
<span id="cb9-4"><a href="#cb9-4"></a>y_test <span class="op">=</span> np.array(gen_states[gen_states.shape[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span>:])</span>
<span id="cb9-5"><a href="#cb9-5"></a>gen_model <span class="op">=</span> gen_model.fit(X_train)</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="co"># check base score (non-tuned model)</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>gen_score <span class="op">=</span> gen_model.score(X_test)</span>
<span id="cb9-9"><a href="#cb9-9"></a></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="bu">print</span>(<span class="ss">f'Generated score: </span><span class="sc">{</span>gen_score<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb9-11"><a href="#cb9-11"></a></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="co"># use the Viterbi algorithm to predict the most likely sequence of states</span></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="co"># given the model</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>states <span class="op">=</span> gen_model.predict(X_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Even though the 'startprob_' attribute is set, it will be overwritten during initialization because 'init_params' contains 's'
Even though the 'transmat_' attribute is set, it will be overwritten during initialization because 'init_params' contains 't'
Even though the 'emissionprob_' attribute is set, it will be overwritten during initialization because 'init_params' contains 'e'</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Generated score: -26290.379422637572</code></pre>
</div>
</div>
<p>Recovered states vs Generated states:</p>
<div class="cell" data-execution_count="8">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>ax.plot(gen_states[:<span class="dv">500</span>], label<span class="op">=</span><span class="st">'generated'</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>ax.plot(states[:<span class="dv">500</span>] <span class="op">+</span> <span class="fl">1.5</span>, label<span class="op">=</span><span class="st">'recovered'</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'States compared to generated'</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Time (# rolls)'</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'State'</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>fig.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\Anu2001\AppData\Local\Temp\ipykernel_2396\4070381187.py:9: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Probability_files/figure-html/cell-9-output-2.png" width="540" height="449"></p>
</div>
</div>
<p>Updated Markov Model probabilities after training the HMM on the dataset with the Baum-Welch algorithm.</p>
<div class="cell" data-execution_count="9">
<div class="cell-output cell-output-stdout">
<pre><code>Transition Model:
Emission Matrix:</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Probability_files/figure-html/cell-10-output-2.png" width="466" height="463"></p>
</div>
<div class="cell-output cell-output-display" data-execution_count="9">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Fair</th>
<th data-quarto-table-cell-role="th">Unfair</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">1</td>
<td>0.150</td>
<td>0.001</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2</td>
<td>0.143</td>
<td>0.001</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">3</td>
<td>0.145</td>
<td>0.000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">4</td>
<td>0.140</td>
<td>0.988</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">5</td>
<td>0.144</td>
<td>0.008</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Results of the model in the form of a confusion matrix to identify how many times the model predicted â€˜Fairâ€™ and â€˜Loadedâ€™ coin correctly given the dice roll.</p>
<p>As we can see from the results below, the accuracy of the model is not considered to be extremely good. This is because we are dealing with a truly probabilistic model, the results are based on the â€˜likelihoodâ€™ parameter. Also, the model has been trained on sample data which may not mimic true data to the fullest.</p>
<div class="cell" data-execution_count="10">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix, classification_report, ConfusionMatrixDisplay</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> RocCurveDisplay</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co"># True states (hidden states)</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>true_states <span class="op">=</span> y_test</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>predicted_states <span class="op">=</span> states</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluate confusion matrix</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>conf_matrix <span class="op">=</span> confusion_matrix(true_states, predicted_states)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Display confusion matrix</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Confusion Matrix:"</span>)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>conf_matrix, display_labels<span class="op">=</span>[<span class="st">'Fair'</span>, <span class="st">'Loaded'</span>])</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>disp.plot()</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluate classification report</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>class_report <span class="op">=</span> classification_report(true_states, predicted_states)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Display classification report</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Classification Report:"</span>)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(class_report)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>RocCurveDisplay.from_predictions(true_states, predicted_states)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Confusion Matrix:
Classification Report:
              precision    recall  f1-score   support

           0       0.67      1.00      0.81     10119
           1       0.00      0.00      0.00      4881

    accuracy                           0.67     15000
   macro avg       0.34      0.50      0.40     15000
weighted avg       0.46      0.67      0.54     15000
</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Probability_files/figure-html/cell-11-output-2.png" width="561" height="430"></p>
</div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>&lt;sklearn.metrics._plot.roc_curve.RocCurveDisplay at 0x20f881d1360&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Probability_files/figure-html/cell-11-output-4.png" width="589" height="429"></p>
</div>
</div>
<div class="cell" data-execution_count="11">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convert_to_numpy(string_val, <span class="bu">type</span>):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    str_int <span class="op">=</span> []</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span> <span class="op">==</span> <span class="st">"rolls"</span>:</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> string_val:</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>            str_int.append(np.array([<span class="bu">int</span>(i)<span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        dice <span class="op">=</span> {<span class="st">'F'</span>:<span class="dv">0</span>, <span class="st">'L'</span>:<span class="dv">1</span>}</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> string_val:</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>            str_int.append(np.array(dice[i]))</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> str_int</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convert_to_string(string_die):</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    dice <span class="op">=</span> {<span class="dv">0</span>: <span class="st">'F'</span>, <span class="dv">1</span>:<span class="st">'L'</span>}</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    string <span class="op">=</span> <span class="st">""</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> string_die:</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        string<span class="op">+=</span>dice[i]</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> string</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Testing the model on an example taken from the textbook: <img src="posts/Probability/HMM_test_sets.JPG" class="img-fluid" alt="HMM example">{width = 60%}</p>
<div class="cell" data-execution_count="12">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>test_rolls1 <span class="op">=</span> <span class="st">"315116246446644245311321631164152133625144543631656626566666"</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>y_true1 <span class="op">=</span> <span class="st">"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFLLLLLLLLLLLL"</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>test_rolls2 <span class="op">=</span> <span class="st">"222555441666566563564324364131513465146353411126414626253356"</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>y_true2 <span class="op">=</span> <span class="st">"FFFFFFFFLLLLLLLLLLLLLFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFL"</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>X_test_1 <span class="op">=</span> convert_to_numpy(test_rolls1, <span class="st">"rolls"</span>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>y_test_1 <span class="op">=</span> gen_model.predict(X_test_1)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> convert_to_string(y_test_1)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output:</span><span class="sc">{</span>test_rolls1<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss">Die:</span><span class="sc">{</span>y_true1<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss">Viterbi:</span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>X_test_2 <span class="op">=</span> convert_to_numpy(test_rolls2, <span class="st">"rolls"</span>)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>y_test_2 <span class="op">=</span> gen_model.predict(X_test_2)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> convert_to_string(y_test_2)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output:</span><span class="sc">{</span>test_rolls2<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss">Die:</span><span class="sc">{</span>y_true2<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss">Viterbi:</span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Output:315116246446644245311321631164152133625144543631656626566666 
Die:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFLLLLLLLLLLLL 
Viterbi:LFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
Output:222555441666566563564324364131513465146353411126414626253356 
Die:FFFFFFFFLLLLLLLLLLLLLFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFL 
Viterbi:LFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code></pre>
</div>
</div>
<p>Detailing the probability theory behind the Hidden Markov Model The Baum-Welch algorithm, also known as the Forward-Backward algorithm, is a parameter estimation technique for Hidden Markov Models (HMMs). Named after Leonard Baum and Lloyd Welch, this algorithm is a form of the Expectation-Maximization (EM) algorithm. Its primary goal is to iteratively refine the parameters of an HMM based on observed data, making it a powerful tool for model training.</p>
<p>The algorithm consists of two main steps, the expectation step and the maximization step.</p>
<p>The parameters of a HMM are given by <span class="math inline">\(\theta=(A,B,\pi)\)</span>, where:</p>
<ul>
<li><span class="math inline">\(A\)</span> is the state transition matrix, which defines the probability of transitioning from one state to another.</li>
<li><span class="math inline">\(B\)</span> is the emission matrix, which defines the probability of emitting a given observation from a given state.</li>
<li><span class="math inline">\(\pi\)</span> is the initial state distribution, which defines the probability of being in each state at the beginning of the sequence.</li>
</ul>
<p><span class="math display">\[\(A=\{a_{ij}\}=P(X_{t}=j|X_{t-1}=i)\) is the state transition matrix\]</span></p>
<p><span class="math display">\[\(\pi=\{\pi_{i}\}=P(X_{1}=i)\) is the initial state distribution\]</span></p>
<p><span class="math display">\[\(B=\{b_{j}(y_{t})\}=P(Y_{t}=y_{t}|X_{t}=j)\) is the emission matrix\]</span></p>
<p>Given observation sequences <span class="math display">\[(Y=(Y_{1}=y_{1},Y_{2}=y_{2},...,Y_{T}=y_{T}))\]</span> the algorithm tries to find the parameters <span class="math display">\[(\theta)\]</span> that maximise the probability of the observation.</p>
<p>The algorithm starts by choosing some initial values for the HMM parameters <span class="math inline">\(\theta = (A, B, \pi)\)</span>. Then, it repeats the following steps until convergence:</p>
<ol type="1">
<li>Determine probable state paths. This involves calculating the probability of each possible state path, given the observed sequence of emissions.</li>
<li>Count the expected number of transitions and emissions. This involves counting the number of times each state transition is taken and each emission is made, weighted by the probability of each state path.</li>
<li>Re-estimate the HMM parameters. This involves using the expected number of transitions and emissions to update the HMM parameters <span class="math inline">\(\theta\)</span>.</li>
</ol>
<p>The forward-backward algorithm is used for finding probable paths.</p>
<p>$$ Forward Procedure (<em>{i}(t)=P(Y</em>{1}=y_{1},â€¦,Y_{t}=y_{t},X_{t}=i|)) be the probability of seeing (y_{1},â€¦,y_{t}) and being in state i at time t. Found recursively using: \ (<em>{i}(1)=</em>{i}b_{i}(y_{1})) \ (<em>{j}(t+1)=b</em>{j}(y_{t+1})<em>{i=1}^{N}</em>{i}(t)a_{ij}) \</p>
<p>Backward Procedure (<em>{i}(t)=P(Y</em>{t+1}=y_{t+1},â€¦,Y_{T}=y_{T}|X_{t}=i,)) be the probability of ending partial sequence (y_{t+1},â€¦,y_{T}) given starting state i at time t. \ (<em>{i}(t)) is computed recursively as: \ (</em>{i}(T)=1)\ (<em>{i}(t)=</em>{j=1}^{N}<em>{j}(t+1)a</em>{ij}b_{j}(y_{t+1})) $$</p>
<div class="cell" data-execution_count="13">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> forward(states, sequence, a, b, pi, key):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(states)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="bu">len</span>(sequence)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> pi[key] <span class="co"># prob of state i, since 2 states, let's half it be 0.5, 0.5 initially</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> key <span class="co"># holds the first state</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Pseudocount to handle zeros</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    pseudocount <span class="op">=</span> <span class="fl">1e-100</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># for all possible states, and the first actual state (alpha)</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># i.e. alpha i for all i has been caluclated given yt</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> np.zeros((N, T))</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    alpha[:,<span class="dv">0</span>] <span class="op">=</span> pi <span class="op">*</span> b[:,<span class="bu">int</span>(sequence[<span class="dv">0</span>])] <span class="op">+</span> pseudocount</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># next, we have to do iterations to calculate alpha at different times t</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># we need all alpha values since it is going to be summed up to calculate gamma</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, T):</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>            alpha[j][t] <span class="op">=</span> <span class="bu">sum</span>(alpha[i][t<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>a[i][j]<span class="op">*</span>b[j][<span class="bu">int</span>(sequence[t])] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N)) <span class="op">+</span> pseudocount</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> alpha</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="14">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backward(states, sequence, a, b):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(states)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="bu">len</span>(sequence)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> np.zeros((N, T))</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Pseudocount to handle zeros</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    pseudocount <span class="op">=</span> <span class="fl">1e-100</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialization</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    beta[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Set the last column to 1</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Recursion</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(T <span class="op">-</span> <span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>            beta[i, t] <span class="op">=</span> <span class="bu">sum</span>(a[i, j] <span class="op">*</span> b[j, <span class="bu">int</span>(sequence[t <span class="op">+</span> <span class="dv">1</span>])] <span class="op">*</span> beta[j, t <span class="op">+</span> <span class="dv">1</span>] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N)) <span class="op">+</span> pseudocount</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> beta</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The Expectation step: Calculate the probabilities of being in each state at each time step given the observed sequence using the Forward-Backward algorithm. These probabilities represent the likelihood of the system being in state <span class="math inline">\(i\)</span> at time <span class="math display">\[t\]</span> given the entire observed sequence. Calculate the joint probabilities of transitioning from state <span class="math display">\[i\]</span> to state <span class="math display">\[j\]</span> at consecutive time steps given the observed sequence.</p>
<p><span class="math display">\[
\gamma_t(i) = \frac{\alpha_t(i) \cdot \beta_t(i)}{\sum_{j=1}^{N} \alpha_t(j) \cdot \beta_t(j)}
\\
\xi_t(i, j) = \frac{\alpha_t(i) \cdot a_{ij} \cdot b_j(o_{t+1}) \cdot \beta_{t+1}(j)}{\sum_{k=1}^{N} \sum_{l=1}^{N} \alpha_t(k) \cdot a_{kl} \cdot b_l(o_{t+1}) \cdot \beta_{t+1}(l)}
\]</span></p>
<p>The Maximization step: Update the model parameters, including the initial state probabilities, transition probabilities, and emission probabilities. The updated parameters are computed by normalizing the expected counts derived from the E-step.</p>
<p>$$</p>
<p>_i = _1(i) //</p>
<p>_{ij} = //</p>
<p>_i(k) = // $$</p>
<div class="cell" data-execution_count="15">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train(a, b, pi, sequence, states, key, n_iterations <span class="op">=</span> <span class="dv">100</span>, tol<span class="op">=</span><span class="fl">1e-6</span>):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Baum-Welch algorithm for HMM</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># calculate gamma, xi, and then update a and b parameters</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(states)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="bu">len</span>(sequence)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># M is the number of possible observations i.e. number of columns</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> b.shape[<span class="dv">1</span>]</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    prev_log_likelihood <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> iteration <span class="kw">in</span> <span class="bu">range</span>(n_iterations):</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>        alpha <span class="op">=</span> forward(states, sequence, a, b, pi, key)</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>        beta <span class="op">=</span> backward(states, sequence, a, b)</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Alpha: </span><span class="sc">{</span>alpha<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Beta:</span><span class="sc">{</span>beta<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Pseudocount to handle zeros</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>        pseudocount <span class="op">=</span> <span class="fl">1e-100</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>        gamma <span class="op">=</span> alpha <span class="op">*</span> beta</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(gamma)</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>        denominator <span class="op">=</span> np.<span class="bu">sum</span>(gamma, axis<span class="op">=</span><span class="dv">0</span>, keepdims<span class="op">=</span><span class="va">True</span>) <span class="co"># same for all i</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>        gamma <span class="op">=</span> gamma<span class="op">/</span>denominator <span class="op">+</span> pseudocount</span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"gamma:</span><span class="sc">{</span>gamma<span class="sc">}</span><span class="ss">"</span>) </span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>        xi <span class="op">=</span> np.zeros((N, N, T <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(T <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>                    numerator <span class="op">=</span> alpha[i, t] <span class="op">*</span> a[i, j] <span class="op">*</span> b[j, <span class="bu">int</span>(sequence[t <span class="op">+</span> <span class="dv">1</span>])] <span class="op">*</span> beta[j, t <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>                    denominator <span class="op">=</span> np.<span class="bu">sum</span>(alpha[k, t] <span class="op">*</span> a[k, l] <span class="op">*</span> b[l, <span class="bu">int</span>(sequence[t <span class="op">+</span> <span class="dv">1</span>])] <span class="op">*</span> beta[l, t <span class="op">+</span> <span class="dv">1</span>] <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(N) <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(N))</span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>                    xi[i, j, t] <span class="op">=</span> (numerator <span class="op">/</span> denominator) <span class="op">+</span> pseudocount</span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Xi: </span><span class="sc">{</span>xi<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a>        <span class="co"># update a and b</span></span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a>        <span class="co"># M-step</span></span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a><span class="co">        sequence == k creates a boolean array of the same length as sequence, where each element is True if the corresponding element in sequence is equal to k, and False otherwise.</span></span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a><span class="co">    mask = (sequence == k) assigns this boolean array to the variable mask.</span></span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a><span class="co">    In the context of the Baum-Welch algorithm or similar algorithms for Hidden Markov Models (HMMs), this kind of mask is often used to select specific observations in the computation of probabilities. For example, </span></span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a><span class="co">    it might be used to sum over only the observations that match a particular value, which is relevant when updating the emission matrix b.</span></span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a>        <span class="co"># a = (np.sum(xi, axis=2) + pseudocount)/ np.sum(gamma[:, :-1], axis=1, keepdims=True) </span></span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):  <span class="co"># N is the number of states</span></span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N):  <span class="co"># N is the number of states</span></span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a>                numerator <span class="op">=</span> np.<span class="bu">sum</span>(xi[i, j, :])</span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a>                denominator <span class="op">=</span> np.<span class="bu">sum</span>(gamma[i, :])</span>
<span id="cb23-53"><a href="#cb23-53" aria-hidden="true" tabindex="-1"></a>                a[i, j] <span class="op">=</span> (numerator<span class="op">+</span>pseudocount) <span class="op">/</span> (denominator<span class="op">+</span>pseudocount) </span>
<span id="cb23-54"><a href="#cb23-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-55"><a href="#cb23-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-56"><a href="#cb23-56" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> np.zeros((N, M))</span>
<span id="cb23-57"><a href="#cb23-57" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(gamma.shape)</span></span>
<span id="cb23-58"><a href="#cb23-58" aria-hidden="true" tabindex="-1"></a>        gamma_sum <span class="op">=</span> np.<span class="bu">sum</span>(gamma, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb23-59"><a href="#cb23-59" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb23-60"><a href="#cb23-60" aria-hidden="true" tabindex="-1"></a>        obs <span class="op">=</span> []</span>
<span id="cb23-61"><a href="#cb23-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> sequence:</span>
<span id="cb23-62"><a href="#cb23-62" aria-hidden="true" tabindex="-1"></a>            obs.append(<span class="bu">int</span>(i))</span>
<span id="cb23-63"><a href="#cb23-63" aria-hidden="true" tabindex="-1"></a>        obs <span class="op">=</span> np.array(obs)</span>
<span id="cb23-64"><a href="#cb23-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-65"><a href="#cb23-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb23-66"><a href="#cb23-66" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(M):</span>
<span id="cb23-67"><a href="#cb23-67" aria-hidden="true" tabindex="-1"></a>                mask <span class="op">=</span> (obs<span class="op">==</span>k) <span class="co"># for indicative function i.e. 1 if observed = yt, else 0</span></span>
<span id="cb23-68"><a href="#cb23-68" aria-hidden="true" tabindex="-1"></a>                b[j, k] <span class="op">=</span> (np.<span class="bu">sum</span>(gamma[j]<span class="op">*</span>mask)<span class="op">+</span> pseudocount) <span class="op">/</span> (np.<span class="bu">sum</span>(gamma[j]) <span class="op">+</span> pseudocount) </span>
<span id="cb23-69"><a href="#cb23-69" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb23-70"><a href="#cb23-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-71"><a href="#cb23-71" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Normalize rows to ensure each row sums to 1.0</span></span>
<span id="cb23-72"><a href="#cb23-72" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> a <span class="op">/</span> np.<span class="bu">sum</span>(a, axis<span class="op">=</span><span class="dv">1</span>)[:, np.newaxis]</span>
<span id="cb23-73"><a href="#cb23-73" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> b <span class="op">/</span> np.<span class="bu">sum</span>(b, axis<span class="op">=</span><span class="dv">1</span>)[:, np.newaxis]</span>
<span id="cb23-74"><a href="#cb23-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-75"><a href="#cb23-75" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"a = </span><span class="sc">{</span>a<span class="sc">}</span><span class="ss">, b = </span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-76"><a href="#cb23-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-77"><a href="#cb23-77" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Log Likelihood Calculation</span></span>
<span id="cb23-78"><a href="#cb23-78" aria-hidden="true" tabindex="-1"></a>        log_likelihood <span class="op">=</span> np.<span class="bu">sum</span>(np.log(np.<span class="bu">sum</span>(alpha, axis<span class="op">=</span><span class="dv">0</span>)))</span>
<span id="cb23-79"><a href="#cb23-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-80"><a href="#cb23-80" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convergence Check</span></span>
<span id="cb23-81"><a href="#cb23-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.<span class="bu">abs</span>(log_likelihood <span class="op">-</span> prev_log_likelihood) <span class="op">&lt;</span> tol:</span>
<span id="cb23-82"><a href="#cb23-82" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Converged after </span><span class="sc">{</span>iteration <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss"> iterations."</span>)</span>
<span id="cb23-83"><a href="#cb23-83" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb23-84"><a href="#cb23-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-85"><a href="#cb23-85" aria-hidden="true" tabindex="-1"></a>        prev_log_likelihood <span class="op">=</span> log_likelihood</span>
<span id="cb23-86"><a href="#cb23-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-87"><a href="#cb23-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a, b, pi</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The Viterbi algorithm is a dynamic programming algorithm used for decoding Hidden Markov Models (HMMs) and finding the most likely sequence of hidden states given an observed sequence. The algorithm efficiently determines the optimal state sequence by considering the probabilities of transitions and emissions.</p>
<p>The core idea behind the Viterbi algorithm is to iteratively compute the most likely path to each state at each time step, incorporating both the current observation and the previously calculated probabilities.</p>
<p><span class="math display">\[
Î´_i(t) = max_j Î´_j(t - 1) a_ji b_i(Y_t)
\]</span></p>
<p><span class="math display">\[
Ïˆ_i(t) = argmax_j Î´_j(t - 1) a_ji
\]</span></p>
<div class="cell" data-execution_count="16">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> predict(sequence, states, a, b, pi):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Makes use of the viterbi algorithm to predict best path</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize Variables</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="bu">len</span>(sequence)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(states)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Pseudocount to handle zeros</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    pseudocount <span class="op">=</span> <span class="fl">1e-100</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    viterbi_table <span class="op">=</span> np.zeros((N, T)) <span class="co"># delta</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    backpointer <span class="op">=</span> np.zeros((N, T)) <span class="co"># psi</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialization step, for t = 0</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="bu">int</span>(sequence[<span class="dv">0</span>]))</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    viterbi_table[:, <span class="dv">0</span>] <span class="op">=</span> pi <span class="op">*</span> b[:, <span class="bu">int</span>(sequence[<span class="dv">0</span>])] <span class="op">+</span> pseudocount</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate Probabilities</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, T):</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> s <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>            max_prob <span class="op">=</span> <span class="bu">max</span>(viterbi_table[prev_s][t<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> a[prev_s][s] <span class="cf">for</span> prev_s <span class="kw">in</span> <span class="bu">range</span>(N)) <span class="op">*</span> b[s][<span class="bu">int</span>(sequence[t])] </span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>            viterbi_table[s][t] <span class="op">=</span> max_prob <span class="op">+</span> pseudocount</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>            backpointer[s][t] <span class="op">=</span> np.argmax([viterbi_table[prev_s][t<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> a[prev_s][s]<span class="cf">for</span> prev_s <span class="kw">in</span> <span class="bu">range</span>(N)])</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Traceback and Find Best Path</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>    best_path <span class="op">=</span> []</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>    last_state <span class="op">=</span> np.argmax(viterbi_table[:, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>    best_path.append(last_state)</span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>    best_prob <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(T<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>        last_state <span class="op">=</span> last_state <span class="op">=</span> np.argmax(viterbi_table[:, t])</span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>        best_prob <span class="op">*=</span> (viterbi_table[last_state, t] <span class="op">+</span> pseudocount)</span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a>        best_path.append(last_state) <span class="co"># i.e. add to start of list</span></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_path</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>


<!-- -->


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          // default icon
          link.classList.add("external");
      }
    }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb25" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Probability Theory"</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> "Anushka S"</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> "2023-12-03"</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span><span class="co"> [Probability Theory, Machine Learning, Random Variables, Hidden Markov Models, Viterbi algorithm, Baum Welch]</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>Hidden Markov Models (HMMs) are a powerful statistical tool used in various fields, including speech recognition, bioinformatics, and natural language processing. Grounded in probability theory, HMMs are a type of stochastic model that represents a system evolving over time with hidden states. The model assumes that the observed data result from a probabilistic process involving these hidden states, making it particularly effective in situations where the underlying dynamics are not directly observable but can be inferred through observed data and the probabilities governing state transitions and emissions. Probability theory forms the backbone of HMMs, allowing them to make predictions and decisions based on the likelihood of sequences of observations given the model's parameters.</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>The <span class="co">[</span><span class="ot">hmmlearn</span><span class="co">]</span> library in Python performs Unsupervised learning and inference of Hidden Markov Models.  </span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>Let us take the common Hidden Markov Model example of the ocassionally dishonest casino. In a casino, they use a fair die most of the time, but switch to the loaded die once in a while. The purpose of making use of the Hidden Markov Model is to identify instances when the dice roll is probabilistically from the fair die or the loaded die. </span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>The probabilities for the various outcome variables have been adapted from <span class="co">[</span><span class="ot">this textbook</span><span class="co">](https://doi.org/10.1017/CBO9780511790492)</span>.</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a><span class="al">![Markov Model for dishonest casino](dice_prob.JPG)</span>{width=80%}</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>The emission probabilities are the probability of each outcome (die roll) at its current state. The transition probabilities define the probability of transitioning to a state (fair, loaded), and the start probabilities define the starting probability of being in each state.</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>From the hmmlearn library, the CategoricalHMM model (derived from the MultinomialHMM model), uses the Baum-Welch algorithm for training hidden Markov models (HMMs). The Baum-Welch algorithm, also known as the Forward-Backward algorithm or the Expectation-Maximization (EM) algorithm for HMMs, is an iterative procedure for estimating the parameters of an HMM given a set of observed data.</span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>You can read more on the training of the Hidden Markov Model and the probability theory behind identifying the sequence state part at the end of this blog.</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>In the block of code below, we initialize the probabilities, initialize the CategoricalHMM method which takes in n_components as the number of possible states, the number of iterations for training. The other parameters (such as init_param, algorithm, etc.) details can be found <span class="co">[</span><span class="ot">here</span><span class="co">](https://hmmlearn.readthedocs.io/en/latest/api.html#categoricalhmm)</span>.</span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>We then use the sample() method to generate die roll and corresponding state samples.</span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: false</span></span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-line-numbers: true</span></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> hmmlearn <span class="im">import</span> hmm</span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a>gen_model <span class="op">=</span> hmm.CategoricalHMM(n_components<span class="op">=</span><span class="dv">2</span>, n_iter<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a>gen_model.startprob_ <span class="op">=</span> np.array([<span class="fl">1.0</span>, <span class="fl">0.0</span>])</span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a>gen_model.transmat_ <span class="op">=</span> np.array([[<span class="fl">0.95</span>, <span class="fl">0.05</span>],</span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>                                [<span class="fl">0.1</span>, <span class="fl">0.9</span>]])</span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a>gen_model.emissionprob_ <span class="op">=</span> <span class="op">\</span></span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>    np.array([[<span class="dv">1</span> <span class="op">/</span> <span class="dv">6</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">6</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">6</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">6</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">6</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">6</span>],</span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span> <span class="op">/</span> <span class="dv">10</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">10</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">10</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">10</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">10</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">2</span>]])</span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a>rolls, gen_states <span class="op">=</span> gen_model.sample(<span class="dv">30000</span>)</span>
<span id="cb25-56"><a href="#cb25-56" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-57"><a href="#cb25-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-60"><a href="#cb25-60" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-61"><a href="#cb25-61" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb25-62"><a href="#cb25-62" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt </span>
<span id="cb25-63"><a href="#cb25-63" aria-hidden="true" tabindex="-1"></a><span class="co"># Import the MarkovChain class from markovchain.py</span></span>
<span id="cb25-64"><a href="#cb25-64" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> markovchain <span class="im">import</span> MarkovChain</span>
<span id="cb25-65"><a href="#cb25-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-66"><a href="#cb25-66" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> gen_model.transmat_</span>
<span id="cb25-67"><a href="#cb25-67" aria-hidden="true" tabindex="-1"></a>mc <span class="op">=</span> MarkovChain(P, [<span class="st">'Fair'</span>, <span class="st">'Loaded'</span>])</span>
<span id="cb25-68"><a href="#cb25-68" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Transition Model:"</span>)</span>
<span id="cb25-69"><a href="#cb25-69" aria-hidden="true" tabindex="-1"></a>mc.draw()</span>
<span id="cb25-70"><a href="#cb25-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-71"><a href="#cb25-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-72"><a href="#cb25-72" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> {<span class="st">'Fair'</span>: gen_model.emissionprob_[<span class="dv">0</span>], <span class="st">'Unfair'</span>: gen_model.emissionprob_[<span class="dv">1</span>]}</span>
<span id="cb25-73"><a href="#cb25-73" aria-hidden="true" tabindex="-1"></a>df_emission <span class="op">=</span> pd.DataFrame(data, index<span class="op">=</span>[<span class="st">'1'</span>, <span class="st">'2'</span>, <span class="st">'3'</span>, <span class="st">'4'</span>, <span class="st">'5'</span>, <span class="st">'6'</span>])</span>
<span id="cb25-74"><a href="#cb25-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-75"><a href="#cb25-75" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Emission Matrix:"</span>)</span>
<span id="cb25-76"><a href="#cb25-76" aria-hidden="true" tabindex="-1"></a>df_emission.head()</span>
<span id="cb25-77"><a href="#cb25-77" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-78"><a href="#cb25-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-81"><a href="#cb25-81" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-82"><a href="#cb25-82" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb25-83"><a href="#cb25-83" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Sample of Dice Rolls generated"</span>)</span>
<span id="cb25-84"><a href="#cb25-84" aria-hidden="true" tabindex="-1"></a>pd.DataFrame({<span class="st">'Roll'</span>: rolls.flatten()[<span class="dv">0</span>:<span class="dv">10</span>]<span class="op">+</span><span class="dv">1</span>, <span class="st">'Coin_State'</span>: gen_states.flatten()[<span class="dv">0</span>:<span class="dv">10</span>]}).head()</span>
<span id="cb25-85"><a href="#cb25-85" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-86"><a href="#cb25-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-87"><a href="#cb25-87" aria-hidden="true" tabindex="-1"></a>Plotting the states of the first 500 generated coin flips:</span>
<span id="cb25-90"><a href="#cb25-90" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-91"><a href="#cb25-91" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb25-92"><a href="#cb25-92" aria-hidden="true" tabindex="-1"></a>ax.plot(gen_states[:<span class="dv">500</span>])</span>
<span id="cb25-93"><a href="#cb25-93" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'States over time'</span>)</span>
<span id="cb25-94"><a href="#cb25-94" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Time (# of rolls)'</span>)</span>
<span id="cb25-95"><a href="#cb25-95" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'State'</span>)</span>
<span id="cb25-96"><a href="#cb25-96" aria-hidden="true" tabindex="-1"></a>fig.show()</span>
<span id="cb25-97"><a href="#cb25-97" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-98"><a href="#cb25-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-99"><a href="#cb25-99" aria-hidden="true" tabindex="-1"></a>Plotting the rolls for the fair and loaded states</span>
<span id="cb25-102"><a href="#cb25-102" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-103"><a href="#cb25-103" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb25-104"><a href="#cb25-104" aria-hidden="true" tabindex="-1"></a>ax.hist(rolls[gen_states <span class="op">==</span> <span class="dv">0</span>], label<span class="op">=</span><span class="st">'fair'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb25-105"><a href="#cb25-105" aria-hidden="true" tabindex="-1"></a>        bins<span class="op">=</span>np.arange(<span class="dv">7</span>) <span class="op">-</span> <span class="fl">0.5</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb25-106"><a href="#cb25-106" aria-hidden="true" tabindex="-1"></a>ax.hist(rolls[gen_states <span class="op">==</span> <span class="dv">1</span>], label<span class="op">=</span><span class="st">'loaded'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb25-107"><a href="#cb25-107" aria-hidden="true" tabindex="-1"></a>        bins<span class="op">=</span>np.arange(<span class="dv">7</span>) <span class="op">-</span> <span class="fl">0.5</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb25-108"><a href="#cb25-108" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Roll probabilities by state'</span>)</span>
<span id="cb25-109"><a href="#cb25-109" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Count'</span>)</span>
<span id="cb25-110"><a href="#cb25-110" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Roll'</span>)</span>
<span id="cb25-111"><a href="#cb25-111" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb25-112"><a href="#cb25-112" aria-hidden="true" tabindex="-1"></a>fig.show()</span>
<span id="cb25-113"><a href="#cb25-113" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-114"><a href="#cb25-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-115"><a href="#cb25-115" aria-hidden="true" tabindex="-1"></a>In the code below, we are performing a 50%-50% train-test dataset split. </span>
<span id="cb25-116"><a href="#cb25-116" aria-hidden="true" tabindex="-1"></a>We are then fitting the model on our train set and obtaining the score for the model which is simply the log probability under the model.</span>
<span id="cb25-117"><a href="#cb25-117" aria-hidden="true" tabindex="-1"></a>Then, we make use of the predict method which implements the Viterbi algorithm to predict the best sequence of states for the given observations (dice rolls).</span>
<span id="cb25-118"><a href="#cb25-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-121"><a href="#cb25-121" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-122"><a href="#cb25-122" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: false</span></span>
<span id="cb25-123"><a href="#cb25-123" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-line-numbers: true</span></span>
<span id="cb25-124"><a href="#cb25-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-125"><a href="#cb25-125" aria-hidden="true" tabindex="-1"></a><span class="co"># split our data into training and validation sets (50/50 split)</span></span>
<span id="cb25-126"><a href="#cb25-126" aria-hidden="true" tabindex="-1"></a>X_train <span class="op">=</span> rolls[:rolls.shape[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span>]</span>
<span id="cb25-127"><a href="#cb25-127" aria-hidden="true" tabindex="-1"></a>X_test <span class="op">=</span> rolls[rolls.shape[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span>:]</span>
<span id="cb25-128"><a href="#cb25-128" aria-hidden="true" tabindex="-1"></a>y_test <span class="op">=</span> np.array(gen_states[gen_states.shape[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span>:])</span>
<span id="cb25-129"><a href="#cb25-129" aria-hidden="true" tabindex="-1"></a>gen_model <span class="op">=</span> gen_model.fit(X_train)</span>
<span id="cb25-130"><a href="#cb25-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-131"><a href="#cb25-131" aria-hidden="true" tabindex="-1"></a><span class="co"># check base score (non-tuned model)</span></span>
<span id="cb25-132"><a href="#cb25-132" aria-hidden="true" tabindex="-1"></a>gen_score <span class="op">=</span> gen_model.score(X_test)</span>
<span id="cb25-133"><a href="#cb25-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-134"><a href="#cb25-134" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Generated score: </span><span class="sc">{</span>gen_score<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb25-135"><a href="#cb25-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-136"><a href="#cb25-136" aria-hidden="true" tabindex="-1"></a><span class="co"># use the Viterbi algorithm to predict the most likely sequence of states</span></span>
<span id="cb25-137"><a href="#cb25-137" aria-hidden="true" tabindex="-1"></a><span class="co"># given the model</span></span>
<span id="cb25-138"><a href="#cb25-138" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> gen_model.predict(X_test)</span>
<span id="cb25-139"><a href="#cb25-139" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-140"><a href="#cb25-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-141"><a href="#cb25-141" aria-hidden="true" tabindex="-1"></a>Recovered states vs Generated states:</span>
<span id="cb25-142"><a href="#cb25-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-145"><a href="#cb25-145" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-146"><a href="#cb25-146" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb25-147"><a href="#cb25-147" aria-hidden="true" tabindex="-1"></a>ax.plot(gen_states[:<span class="dv">500</span>], label<span class="op">=</span><span class="st">'generated'</span>)</span>
<span id="cb25-148"><a href="#cb25-148" aria-hidden="true" tabindex="-1"></a>ax.plot(states[:<span class="dv">500</span>] <span class="op">+</span> <span class="fl">1.5</span>, label<span class="op">=</span><span class="st">'recovered'</span>)</span>
<span id="cb25-149"><a href="#cb25-149" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb25-150"><a href="#cb25-150" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'States compared to generated'</span>)</span>
<span id="cb25-151"><a href="#cb25-151" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Time (# rolls)'</span>)</span>
<span id="cb25-152"><a href="#cb25-152" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'State'</span>)</span>
<span id="cb25-153"><a href="#cb25-153" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb25-154"><a href="#cb25-154" aria-hidden="true" tabindex="-1"></a>fig.show()</span>
<span id="cb25-155"><a href="#cb25-155" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-156"><a href="#cb25-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-157"><a href="#cb25-157" aria-hidden="true" tabindex="-1"></a>Updated Markov Model probabilities after training the HMM on the dataset with the Baum-Welch algorithm.</span>
<span id="cb25-160"><a href="#cb25-160" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-161"><a href="#cb25-161" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb25-162"><a href="#cb25-162" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt </span>
<span id="cb25-163"><a href="#cb25-163" aria-hidden="true" tabindex="-1"></a><span class="co"># Import the MarkovChain class from markovchain.py</span></span>
<span id="cb25-164"><a href="#cb25-164" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> markovchain <span class="im">import</span> MarkovChain</span>
<span id="cb25-165"><a href="#cb25-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-166"><a href="#cb25-166" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> gen_model.transmat_.<span class="bu">round</span>(<span class="dv">3</span>)</span>
<span id="cb25-167"><a href="#cb25-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-168"><a href="#cb25-168" aria-hidden="true" tabindex="-1"></a>mc <span class="op">=</span> MarkovChain(P, [<span class="st">'Fair'</span>, <span class="st">'Loaded'</span>])</span>
<span id="cb25-169"><a href="#cb25-169" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Transition Model:"</span>)</span>
<span id="cb25-170"><a href="#cb25-170" aria-hidden="true" tabindex="-1"></a>mc.draw()</span>
<span id="cb25-171"><a href="#cb25-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-172"><a href="#cb25-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-173"><a href="#cb25-173" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> {<span class="st">'Fair'</span>: gen_model.emissionprob_.<span class="bu">round</span>(<span class="dv">3</span>)[<span class="dv">0</span>], <span class="st">'Unfair'</span>: gen_model.emissionprob_.<span class="bu">round</span>(<span class="dv">3</span>)[<span class="dv">1</span>]}</span>
<span id="cb25-174"><a href="#cb25-174" aria-hidden="true" tabindex="-1"></a>df_emission <span class="op">=</span> pd.DataFrame(data, index<span class="op">=</span>[<span class="st">'1'</span>, <span class="st">'2'</span>, <span class="st">'3'</span>, <span class="st">'4'</span>, <span class="st">'5'</span>, <span class="st">'6'</span>])</span>
<span id="cb25-175"><a href="#cb25-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-176"><a href="#cb25-176" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Emission Matrix:"</span>)</span>
<span id="cb25-177"><a href="#cb25-177" aria-hidden="true" tabindex="-1"></a>df_emission.head()</span>
<span id="cb25-178"><a href="#cb25-178" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-179"><a href="#cb25-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-180"><a href="#cb25-180" aria-hidden="true" tabindex="-1"></a>Results of the model in the form of a confusion matrix to identify how many times the model predicted 'Fair' and 'Loaded' coin correctly given the dice roll.</span>
<span id="cb25-181"><a href="#cb25-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-182"><a href="#cb25-182" aria-hidden="true" tabindex="-1"></a>As we can see from the results below, the accuracy of the model is not considered to be extremely good. This is because we are dealing with a truly probabilistic model, the results are based on the 'likelihood' parameter. Also, the model has been trained on sample data which may not mimic true data to the fullest. </span>
<span id="cb25-185"><a href="#cb25-185" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-186"><a href="#cb25-186" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix, classification_report, ConfusionMatrixDisplay</span>
<span id="cb25-187"><a href="#cb25-187" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> RocCurveDisplay</span>
<span id="cb25-188"><a href="#cb25-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-189"><a href="#cb25-189" aria-hidden="true" tabindex="-1"></a><span class="co"># True states (hidden states)</span></span>
<span id="cb25-190"><a href="#cb25-190" aria-hidden="true" tabindex="-1"></a>true_states <span class="op">=</span> y_test</span>
<span id="cb25-191"><a href="#cb25-191" aria-hidden="true" tabindex="-1"></a>predicted_states <span class="op">=</span> states</span>
<span id="cb25-192"><a href="#cb25-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-193"><a href="#cb25-193" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluate confusion matrix</span></span>
<span id="cb25-194"><a href="#cb25-194" aria-hidden="true" tabindex="-1"></a>conf_matrix <span class="op">=</span> confusion_matrix(true_states, predicted_states)</span>
<span id="cb25-195"><a href="#cb25-195" aria-hidden="true" tabindex="-1"></a><span class="co"># Display confusion matrix</span></span>
<span id="cb25-196"><a href="#cb25-196" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Confusion Matrix:"</span>)</span>
<span id="cb25-197"><a href="#cb25-197" aria-hidden="true" tabindex="-1"></a>disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>conf_matrix, display_labels<span class="op">=</span>[<span class="st">'Fair'</span>, <span class="st">'Loaded'</span>])</span>
<span id="cb25-198"><a href="#cb25-198" aria-hidden="true" tabindex="-1"></a>disp.plot()</span>
<span id="cb25-199"><a href="#cb25-199" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb25-200"><a href="#cb25-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-201"><a href="#cb25-201" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluate classification report</span></span>
<span id="cb25-202"><a href="#cb25-202" aria-hidden="true" tabindex="-1"></a>class_report <span class="op">=</span> classification_report(true_states, predicted_states)</span>
<span id="cb25-203"><a href="#cb25-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-204"><a href="#cb25-204" aria-hidden="true" tabindex="-1"></a><span class="co"># Display classification report</span></span>
<span id="cb25-205"><a href="#cb25-205" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Classification Report:"</span>)</span>
<span id="cb25-206"><a href="#cb25-206" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(class_report)</span>
<span id="cb25-207"><a href="#cb25-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-208"><a href="#cb25-208" aria-hidden="true" tabindex="-1"></a>RocCurveDisplay.from_predictions(true_states, predicted_states)</span>
<span id="cb25-209"><a href="#cb25-209" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-210"><a href="#cb25-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-213"><a href="#cb25-213" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-214"><a href="#cb25-214" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convert_to_numpy(string_val, <span class="bu">type</span>):</span>
<span id="cb25-215"><a href="#cb25-215" aria-hidden="true" tabindex="-1"></a>    str_int <span class="op">=</span> []</span>
<span id="cb25-216"><a href="#cb25-216" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span> <span class="op">==</span> <span class="st">"rolls"</span>:</span>
<span id="cb25-217"><a href="#cb25-217" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> string_val:</span>
<span id="cb25-218"><a href="#cb25-218" aria-hidden="true" tabindex="-1"></a>            str_int.append(np.array([<span class="bu">int</span>(i)<span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb25-219"><a href="#cb25-219" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb25-220"><a href="#cb25-220" aria-hidden="true" tabindex="-1"></a>        dice <span class="op">=</span> {<span class="st">'F'</span>:<span class="dv">0</span>, <span class="st">'L'</span>:<span class="dv">1</span>}</span>
<span id="cb25-221"><a href="#cb25-221" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> string_val:</span>
<span id="cb25-222"><a href="#cb25-222" aria-hidden="true" tabindex="-1"></a>            str_int.append(np.array(dice[i]))</span>
<span id="cb25-223"><a href="#cb25-223" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> str_int</span>
<span id="cb25-224"><a href="#cb25-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-225"><a href="#cb25-225" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convert_to_string(string_die):</span>
<span id="cb25-226"><a href="#cb25-226" aria-hidden="true" tabindex="-1"></a>    dice <span class="op">=</span> {<span class="dv">0</span>: <span class="st">'F'</span>, <span class="dv">1</span>:<span class="st">'L'</span>}</span>
<span id="cb25-227"><a href="#cb25-227" aria-hidden="true" tabindex="-1"></a>    string <span class="op">=</span> <span class="st">""</span></span>
<span id="cb25-228"><a href="#cb25-228" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> string_die:</span>
<span id="cb25-229"><a href="#cb25-229" aria-hidden="true" tabindex="-1"></a>        string<span class="op">+=</span>dice[i]</span>
<span id="cb25-230"><a href="#cb25-230" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> string</span>
<span id="cb25-231"><a href="#cb25-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-232"><a href="#cb25-232" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-233"><a href="#cb25-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-234"><a href="#cb25-234" aria-hidden="true" tabindex="-1"></a>Testing the model on an example taken from the textbook:</span>
<span id="cb25-235"><a href="#cb25-235" aria-hidden="true" tabindex="-1"></a><span class="al">![HMM example](posts/Probability/HMM_test_sets.JPG)</span>{width = 60%}</span>
<span id="cb25-236"><a href="#cb25-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-239"><a href="#cb25-239" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-240"><a href="#cb25-240" aria-hidden="true" tabindex="-1"></a>test_rolls1 <span class="op">=</span> <span class="st">"315116246446644245311321631164152133625144543631656626566666"</span></span>
<span id="cb25-241"><a href="#cb25-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-242"><a href="#cb25-242" aria-hidden="true" tabindex="-1"></a>y_true1 <span class="op">=</span> <span class="st">"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFLLLLLLLLLLLL"</span></span>
<span id="cb25-243"><a href="#cb25-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-244"><a href="#cb25-244" aria-hidden="true" tabindex="-1"></a>test_rolls2 <span class="op">=</span> <span class="st">"222555441666566563564324364131513465146353411126414626253356"</span></span>
<span id="cb25-245"><a href="#cb25-245" aria-hidden="true" tabindex="-1"></a>y_true2 <span class="op">=</span> <span class="st">"FFFFFFFFLLLLLLLLLLLLLFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFL"</span></span>
<span id="cb25-246"><a href="#cb25-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-247"><a href="#cb25-247" aria-hidden="true" tabindex="-1"></a>X_test_1 <span class="op">=</span> convert_to_numpy(test_rolls1, <span class="st">"rolls"</span>)</span>
<span id="cb25-248"><a href="#cb25-248" aria-hidden="true" tabindex="-1"></a>y_test_1 <span class="op">=</span> gen_model.predict(X_test_1)</span>
<span id="cb25-249"><a href="#cb25-249" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> convert_to_string(y_test_1)</span>
<span id="cb25-250"><a href="#cb25-250" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output:</span><span class="sc">{</span>test_rolls1<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss">Die:</span><span class="sc">{</span>y_true1<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss">Viterbi:</span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-251"><a href="#cb25-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-252"><a href="#cb25-252" aria-hidden="true" tabindex="-1"></a>X_test_2 <span class="op">=</span> convert_to_numpy(test_rolls2, <span class="st">"rolls"</span>)</span>
<span id="cb25-253"><a href="#cb25-253" aria-hidden="true" tabindex="-1"></a>y_test_2 <span class="op">=</span> gen_model.predict(X_test_2)</span>
<span id="cb25-254"><a href="#cb25-254" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> convert_to_string(y_test_2)</span>
<span id="cb25-255"><a href="#cb25-255" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output:</span><span class="sc">{</span>test_rolls2<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss">Die:</span><span class="sc">{</span>y_true2<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss">Viterbi:</span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-256"><a href="#cb25-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-257"><a href="#cb25-257" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-258"><a href="#cb25-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-259"><a href="#cb25-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-260"><a href="#cb25-260" aria-hidden="true" tabindex="-1"></a>\huge Detailing the probability theory behind the Hidden Markov Model</span>
<span id="cb25-261"><a href="#cb25-261" aria-hidden="true" tabindex="-1"></a>The Baum-Welch algorithm, also known as the Forward-Backward algorithm, is a parameter estimation technique for Hidden Markov Models (HMMs). Named after Leonard Baum and Lloyd Welch, this algorithm is a form of the Expectation-Maximization (EM) algorithm. Its primary goal is to iteratively refine the parameters of an HMM based on observed data, making it a powerful tool for model training.</span>
<span id="cb25-262"><a href="#cb25-262" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-263"><a href="#cb25-263" aria-hidden="true" tabindex="-1"></a>The algorithm consists of two main steps, the expectation step and the maximization step.</span>
<span id="cb25-264"><a href="#cb25-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-265"><a href="#cb25-265" aria-hidden="true" tabindex="-1"></a>The parameters of a HMM are given by $\theta=(A,B,\pi)$, where:</span>
<span id="cb25-266"><a href="#cb25-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-267"><a href="#cb25-267" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$A$ is the state transition matrix, which defines the probability of transitioning from one state to another.</span>
<span id="cb25-268"><a href="#cb25-268" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$B$ is the emission matrix, which defines the probability of emitting a given observation from a given state.</span>
<span id="cb25-269"><a href="#cb25-269" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$\pi$ is the initial state distribution, which defines the probability of being in each state at the beginning of the sequence.</span>
<span id="cb25-270"><a href="#cb25-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-271"><a href="#cb25-271" aria-hidden="true" tabindex="-1"></a>$$<span class="sc">\(</span>A=<span class="sc">\{</span>a_{ij}<span class="sc">\}</span>=P(X_{t}=j|X_{t-1}=i)<span class="sc">\)</span> is the state transition matrix$$</span>
<span id="cb25-272"><a href="#cb25-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-273"><a href="#cb25-273" aria-hidden="true" tabindex="-1"></a>$$<span class="sc">\(</span>\pi=<span class="sc">\{</span>\pi_{i}<span class="sc">\}</span>=P(X_{1}=i)<span class="sc">\)</span> is the initial state distribution$$</span>
<span id="cb25-274"><a href="#cb25-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-275"><a href="#cb25-275" aria-hidden="true" tabindex="-1"></a>$$<span class="sc">\(</span>B=<span class="sc">\{</span>b_{j}(y_{t})<span class="sc">\}</span>=P(Y_{t}=y_{t}|X_{t}=j)<span class="sc">\)</span> is the emission matrix$$</span>
<span id="cb25-276"><a href="#cb25-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-277"><a href="#cb25-277" aria-hidden="true" tabindex="-1"></a>Given observation sequences $$(Y=(Y_{1}=y_{1},Y_{2}=y_{2},...,Y_{T}=y_{T}))$$ the</span>
<span id="cb25-278"><a href="#cb25-278" aria-hidden="true" tabindex="-1"></a>algorithm tries to find the parameters $$(\theta)$$ that maximise the probability of the</span>
<span id="cb25-279"><a href="#cb25-279" aria-hidden="true" tabindex="-1"></a>observation.</span>
<span id="cb25-280"><a href="#cb25-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-281"><a href="#cb25-281" aria-hidden="true" tabindex="-1"></a>The algorithm starts by choosing some initial values for the HMM parameters $\theta = (A, B, \pi)$. Then, it repeats the following steps until convergence:</span>
<span id="cb25-282"><a href="#cb25-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-283"><a href="#cb25-283" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Determine probable state paths. This involves calculating the probability of each possible state path, given the observed sequence of emissions.</span>
<span id="cb25-284"><a href="#cb25-284" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Count the expected number of transitions and emissions. This involves counting the number of times each state transition is taken and each emission is made, weighted by the probability of each state path.</span>
<span id="cb25-285"><a href="#cb25-285" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Re-estimate the HMM parameters. This involves using the expected number of transitions and emissions to update the HMM parameters $\theta$.</span>
<span id="cb25-286"><a href="#cb25-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-287"><a href="#cb25-287" aria-hidden="true" tabindex="-1"></a>The forward-backward algorithm is used for finding probable paths.</span>
<span id="cb25-288"><a href="#cb25-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-289"><a href="#cb25-289" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-290"><a href="#cb25-290" aria-hidden="true" tabindex="-1"></a>Forward Procedure</span>
<span id="cb25-291"><a href="#cb25-291" aria-hidden="true" tabindex="-1"></a>(\alpha_{i}(t)=P(Y_{1}=y_{1},...,Y_{t}=y_{t},X_{t}=i|\theta)) be the probability of seeing (y_{1},...,y_{t}) and being in state i at time t. Found recursively using:</span>
<span id="cb25-292"><a href="#cb25-292" aria-hidden="true" tabindex="-1"></a><span class="sc">\\</span></span>
<span id="cb25-293"><a href="#cb25-293" aria-hidden="true" tabindex="-1"></a><span class="sc">\(</span>\alpha_{i}(1)=\pi_{i}b_{i}(y_{1})<span class="sc">\)</span></span>
<span id="cb25-294"><a href="#cb25-294" aria-hidden="true" tabindex="-1"></a><span class="sc">\\</span></span>
<span id="cb25-295"><a href="#cb25-295" aria-hidden="true" tabindex="-1"></a><span class="sc">\(</span>\alpha_{j}(t+1)=b_{j}(y_{t+1})\sum_{i=1}^{N}\alpha_{i}(t)a_{ij}<span class="sc">\)</span></span>
<span id="cb25-296"><a href="#cb25-296" aria-hidden="true" tabindex="-1"></a><span class="sc">\\</span></span>
<span id="cb25-297"><a href="#cb25-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-298"><a href="#cb25-298" aria-hidden="true" tabindex="-1"></a>Backward Procedure</span>
<span id="cb25-299"><a href="#cb25-299" aria-hidden="true" tabindex="-1"></a>(\beta_{i}(t)=P(Y_{t+1}=y_{t+1},...,Y_{T}=y_{T}|X_{t}=i,\theta)) be the probability of ending partial sequence (y_{t+1},...,y_{T}) given starting state i at time t. </span>
<span id="cb25-300"><a href="#cb25-300" aria-hidden="true" tabindex="-1"></a><span class="sc">\\</span></span>
<span id="cb25-301"><a href="#cb25-301" aria-hidden="true" tabindex="-1"></a>(\beta_{i}(t)) is computed recursively as:</span>
<span id="cb25-302"><a href="#cb25-302" aria-hidden="true" tabindex="-1"></a><span class="sc">\\</span></span>
<span id="cb25-303"><a href="#cb25-303" aria-hidden="true" tabindex="-1"></a><span class="sc">\(</span>\beta_{i}(T)=1<span class="sc">\)\\</span></span>
<span id="cb25-304"><a href="#cb25-304" aria-hidden="true" tabindex="-1"></a><span class="sc">\(</span>\beta_{i}(t)=\sum_{j=1}^{N}\beta_{j}(t+1)a_{ij}b_{j}(y_{t+1}))</span>
<span id="cb25-305"><a href="#cb25-305" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-306"><a href="#cb25-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-309"><a href="#cb25-309" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-310"><a href="#cb25-310" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> forward(states, sequence, a, b, pi, key):</span>
<span id="cb25-311"><a href="#cb25-311" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(states)</span>
<span id="cb25-312"><a href="#cb25-312" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="bu">len</span>(sequence)</span>
<span id="cb25-313"><a href="#cb25-313" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> pi[key] <span class="co"># prob of state i, since 2 states, let's half it be 0.5, 0.5 initially</span></span>
<span id="cb25-314"><a href="#cb25-314" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> key <span class="co"># holds the first state</span></span>
<span id="cb25-315"><a href="#cb25-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-316"><a href="#cb25-316" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Pseudocount to handle zeros</span></span>
<span id="cb25-317"><a href="#cb25-317" aria-hidden="true" tabindex="-1"></a>    pseudocount <span class="op">=</span> <span class="fl">1e-100</span></span>
<span id="cb25-318"><a href="#cb25-318" aria-hidden="true" tabindex="-1"></a>    <span class="co"># for all possible states, and the first actual state (alpha)</span></span>
<span id="cb25-319"><a href="#cb25-319" aria-hidden="true" tabindex="-1"></a>    <span class="co"># i.e. alpha i for all i has been caluclated given yt</span></span>
<span id="cb25-320"><a href="#cb25-320" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> np.zeros((N, T))</span>
<span id="cb25-321"><a href="#cb25-321" aria-hidden="true" tabindex="-1"></a>    alpha[:,<span class="dv">0</span>] <span class="op">=</span> pi <span class="op">*</span> b[:,<span class="bu">int</span>(sequence[<span class="dv">0</span>])] <span class="op">+</span> pseudocount</span>
<span id="cb25-322"><a href="#cb25-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-323"><a href="#cb25-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-324"><a href="#cb25-324" aria-hidden="true" tabindex="-1"></a>    <span class="co"># next, we have to do iterations to calculate alpha at different times t</span></span>
<span id="cb25-325"><a href="#cb25-325" aria-hidden="true" tabindex="-1"></a>    <span class="co"># we need all alpha values since it is going to be summed up to calculate gamma</span></span>
<span id="cb25-326"><a href="#cb25-326" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-327"><a href="#cb25-327" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, T):</span>
<span id="cb25-328"><a href="#cb25-328" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb25-329"><a href="#cb25-329" aria-hidden="true" tabindex="-1"></a>            alpha[j][t] <span class="op">=</span> <span class="bu">sum</span>(alpha[i][t<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>a[i][j]<span class="op">*</span>b[j][<span class="bu">int</span>(sequence[t])] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N)) <span class="op">+</span> pseudocount</span>
<span id="cb25-330"><a href="#cb25-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-331"><a href="#cb25-331" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> alpha</span>
<span id="cb25-332"><a href="#cb25-332" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-333"><a href="#cb25-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-336"><a href="#cb25-336" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-337"><a href="#cb25-337" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backward(states, sequence, a, b):</span>
<span id="cb25-338"><a href="#cb25-338" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(states)</span>
<span id="cb25-339"><a href="#cb25-339" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="bu">len</span>(sequence)</span>
<span id="cb25-340"><a href="#cb25-340" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> np.zeros((N, T))</span>
<span id="cb25-341"><a href="#cb25-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-342"><a href="#cb25-342" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Pseudocount to handle zeros</span></span>
<span id="cb25-343"><a href="#cb25-343" aria-hidden="true" tabindex="-1"></a>    pseudocount <span class="op">=</span> <span class="fl">1e-100</span></span>
<span id="cb25-344"><a href="#cb25-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-345"><a href="#cb25-345" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialization</span></span>
<span id="cb25-346"><a href="#cb25-346" aria-hidden="true" tabindex="-1"></a>    beta[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Set the last column to 1</span></span>
<span id="cb25-347"><a href="#cb25-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-348"><a href="#cb25-348" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Recursion</span></span>
<span id="cb25-349"><a href="#cb25-349" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(T <span class="op">-</span> <span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb25-350"><a href="#cb25-350" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb25-351"><a href="#cb25-351" aria-hidden="true" tabindex="-1"></a>            beta[i, t] <span class="op">=</span> <span class="bu">sum</span>(a[i, j] <span class="op">*</span> b[j, <span class="bu">int</span>(sequence[t <span class="op">+</span> <span class="dv">1</span>])] <span class="op">*</span> beta[j, t <span class="op">+</span> <span class="dv">1</span>] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N)) <span class="op">+</span> pseudocount</span>
<span id="cb25-352"><a href="#cb25-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-353"><a href="#cb25-353" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> beta</span>
<span id="cb25-354"><a href="#cb25-354" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-355"><a href="#cb25-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-356"><a href="#cb25-356" aria-hidden="true" tabindex="-1"></a>The Expectation step:</span>
<span id="cb25-357"><a href="#cb25-357" aria-hidden="true" tabindex="-1"></a>Calculate the probabilities of being in each state at each time step given the observed sequence using the Forward-Backward algorithm. These probabilities represent the likelihood of the system being in state </span>
<span id="cb25-358"><a href="#cb25-358" aria-hidden="true" tabindex="-1"></a>$i$ at time $$t$$ given the entire observed sequence.</span>
<span id="cb25-359"><a href="#cb25-359" aria-hidden="true" tabindex="-1"></a>Calculate the joint probabilities of transitioning from state $$i$$ to state $$j$$ at consecutive time steps given the observed sequence. </span>
<span id="cb25-360"><a href="#cb25-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-361"><a href="#cb25-361" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-362"><a href="#cb25-362" aria-hidden="true" tabindex="-1"></a>\gamma_t(i) = \frac{\alpha_t(i) \cdot \beta_t(i)}{\sum_{j=1}^{N} \alpha_t(j) \cdot \beta_t(j)}</span>
<span id="cb25-363"><a href="#cb25-363" aria-hidden="true" tabindex="-1"></a><span class="sc">\\</span></span>
<span id="cb25-364"><a href="#cb25-364" aria-hidden="true" tabindex="-1"></a>\xi_t(i, j) = \frac{\alpha_t(i) \cdot a_{ij} \cdot b_j(o_{t+1}) \cdot \beta_{t+1}(j)}{\sum_{k=1}^{N} \sum_{l=1}^{N} \alpha_t(k) \cdot a_{kl} \cdot b_l(o_{t+1}) \cdot \beta_{t+1}(l)}</span>
<span id="cb25-365"><a href="#cb25-365" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-366"><a href="#cb25-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-367"><a href="#cb25-367" aria-hidden="true" tabindex="-1"></a>The Maximization step:</span>
<span id="cb25-368"><a href="#cb25-368" aria-hidden="true" tabindex="-1"></a>Update the model parameters, including the initial state probabilities, transition probabilities, and emission probabilities.</span>
<span id="cb25-369"><a href="#cb25-369" aria-hidden="true" tabindex="-1"></a>The updated parameters are computed by normalizing the expected counts derived from the E-step.</span>
<span id="cb25-370"><a href="#cb25-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-371"><a href="#cb25-371" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-372"><a href="#cb25-372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-373"><a href="#cb25-373" aria-hidden="true" tabindex="-1"></a>\hat{\pi}_i = \gamma_1(i)</span>
<span id="cb25-374"><a href="#cb25-374" aria-hidden="true" tabindex="-1"></a>//</span>
<span id="cb25-375"><a href="#cb25-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-376"><a href="#cb25-376" aria-hidden="true" tabindex="-1"></a>\hat{a}_{ij} = \frac{\sum_{t=1}^{T-1} \xi_t(i, j)}{\sum_{t=1}^{T-1} \gamma_t(i)}</span>
<span id="cb25-377"><a href="#cb25-377" aria-hidden="true" tabindex="-1"></a>//</span>
<span id="cb25-378"><a href="#cb25-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-379"><a href="#cb25-379" aria-hidden="true" tabindex="-1"></a>\hat{b}_i(k) = \frac{\sum_{t=1}^{T} \gamma_t(i) \cdot \delta_{o_t, k}}{\sum_{t=1}^{T} \gamma_t(i)}</span>
<span id="cb25-380"><a href="#cb25-380" aria-hidden="true" tabindex="-1"></a>//</span>
<span id="cb25-381"><a href="#cb25-381" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-382"><a href="#cb25-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-383"><a href="#cb25-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-386"><a href="#cb25-386" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-387"><a href="#cb25-387" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train(a, b, pi, sequence, states, key, n_iterations <span class="op">=</span> <span class="dv">100</span>, tol<span class="op">=</span><span class="fl">1e-6</span>):</span>
<span id="cb25-388"><a href="#cb25-388" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Baum-Welch algorithm for HMM</span></span>
<span id="cb25-389"><a href="#cb25-389" aria-hidden="true" tabindex="-1"></a>    <span class="co"># calculate gamma, xi, and then update a and b parameters</span></span>
<span id="cb25-390"><a href="#cb25-390" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(states)</span>
<span id="cb25-391"><a href="#cb25-391" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="bu">len</span>(sequence)</span>
<span id="cb25-392"><a href="#cb25-392" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-393"><a href="#cb25-393" aria-hidden="true" tabindex="-1"></a>    <span class="co"># M is the number of possible observations i.e. number of columns</span></span>
<span id="cb25-394"><a href="#cb25-394" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> b.shape[<span class="dv">1</span>]</span>
<span id="cb25-395"><a href="#cb25-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-396"><a href="#cb25-396" aria-hidden="true" tabindex="-1"></a>    prev_log_likelihood <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-397"><a href="#cb25-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-398"><a href="#cb25-398" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> iteration <span class="kw">in</span> <span class="bu">range</span>(n_iterations):</span>
<span id="cb25-399"><a href="#cb25-399" aria-hidden="true" tabindex="-1"></a>        alpha <span class="op">=</span> forward(states, sequence, a, b, pi, key)</span>
<span id="cb25-400"><a href="#cb25-400" aria-hidden="true" tabindex="-1"></a>        beta <span class="op">=</span> backward(states, sequence, a, b)</span>
<span id="cb25-401"><a href="#cb25-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-402"><a href="#cb25-402" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Alpha: </span><span class="sc">{</span>alpha<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-403"><a href="#cb25-403" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Beta:</span><span class="sc">{</span>beta<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-404"><a href="#cb25-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-405"><a href="#cb25-405" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Pseudocount to handle zeros</span></span>
<span id="cb25-406"><a href="#cb25-406" aria-hidden="true" tabindex="-1"></a>        pseudocount <span class="op">=</span> <span class="fl">1e-100</span></span>
<span id="cb25-407"><a href="#cb25-407" aria-hidden="true" tabindex="-1"></a>        gamma <span class="op">=</span> alpha <span class="op">*</span> beta</span>
<span id="cb25-408"><a href="#cb25-408" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(gamma)</span></span>
<span id="cb25-409"><a href="#cb25-409" aria-hidden="true" tabindex="-1"></a>        denominator <span class="op">=</span> np.<span class="bu">sum</span>(gamma, axis<span class="op">=</span><span class="dv">0</span>, keepdims<span class="op">=</span><span class="va">True</span>) <span class="co"># same for all i</span></span>
<span id="cb25-410"><a href="#cb25-410" aria-hidden="true" tabindex="-1"></a>        gamma <span class="op">=</span> gamma<span class="op">/</span>denominator <span class="op">+</span> pseudocount</span>
<span id="cb25-411"><a href="#cb25-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-412"><a href="#cb25-412" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"gamma:</span><span class="sc">{</span>gamma<span class="sc">}</span><span class="ss">"</span>) </span>
<span id="cb25-413"><a href="#cb25-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-414"><a href="#cb25-414" aria-hidden="true" tabindex="-1"></a>        xi <span class="op">=</span> np.zeros((N, N, T <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb25-415"><a href="#cb25-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-416"><a href="#cb25-416" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb25-417"><a href="#cb25-417" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb25-418"><a href="#cb25-418" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(T <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb25-419"><a href="#cb25-419" aria-hidden="true" tabindex="-1"></a>                    numerator <span class="op">=</span> alpha[i, t] <span class="op">*</span> a[i, j] <span class="op">*</span> b[j, <span class="bu">int</span>(sequence[t <span class="op">+</span> <span class="dv">1</span>])] <span class="op">*</span> beta[j, t <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb25-420"><a href="#cb25-420" aria-hidden="true" tabindex="-1"></a>                    denominator <span class="op">=</span> np.<span class="bu">sum</span>(alpha[k, t] <span class="op">*</span> a[k, l] <span class="op">*</span> b[l, <span class="bu">int</span>(sequence[t <span class="op">+</span> <span class="dv">1</span>])] <span class="op">*</span> beta[l, t <span class="op">+</span> <span class="dv">1</span>] <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(N) <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(N))</span>
<span id="cb25-421"><a href="#cb25-421" aria-hidden="true" tabindex="-1"></a>                    xi[i, j, t] <span class="op">=</span> (numerator <span class="op">/</span> denominator) <span class="op">+</span> pseudocount</span>
<span id="cb25-422"><a href="#cb25-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-423"><a href="#cb25-423" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Xi: </span><span class="sc">{</span>xi<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-424"><a href="#cb25-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-425"><a href="#cb25-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-426"><a href="#cb25-426" aria-hidden="true" tabindex="-1"></a>        <span class="co"># update a and b</span></span>
<span id="cb25-427"><a href="#cb25-427" aria-hidden="true" tabindex="-1"></a>        <span class="co"># M-step</span></span>
<span id="cb25-428"><a href="#cb25-428" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb25-429"><a href="#cb25-429" aria-hidden="true" tabindex="-1"></a><span class="co">        sequence == k creates a boolean array of the same length as sequence, where each element is True if the corresponding element in sequence is equal to k, and False otherwise.</span></span>
<span id="cb25-430"><a href="#cb25-430" aria-hidden="true" tabindex="-1"></a><span class="co">    mask = (sequence == k) assigns this boolean array to the variable mask.</span></span>
<span id="cb25-431"><a href="#cb25-431" aria-hidden="true" tabindex="-1"></a><span class="co">    In the context of the Baum-Welch algorithm or similar algorithms for Hidden Markov Models (HMMs), this kind of mask is often used to select specific observations in the computation of probabilities. For example, </span></span>
<span id="cb25-432"><a href="#cb25-432" aria-hidden="true" tabindex="-1"></a><span class="co">    it might be used to sum over only the observations that match a particular value, which is relevant when updating the emission matrix b.</span></span>
<span id="cb25-433"><a href="#cb25-433" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb25-434"><a href="#cb25-434" aria-hidden="true" tabindex="-1"></a>        <span class="co"># a = (np.sum(xi, axis=2) + pseudocount)/ np.sum(gamma[:, :-1], axis=1, keepdims=True) </span></span>
<span id="cb25-435"><a href="#cb25-435" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):  <span class="co"># N is the number of states</span></span>
<span id="cb25-436"><a href="#cb25-436" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N):  <span class="co"># N is the number of states</span></span>
<span id="cb25-437"><a href="#cb25-437" aria-hidden="true" tabindex="-1"></a>                numerator <span class="op">=</span> np.<span class="bu">sum</span>(xi[i, j, :])</span>
<span id="cb25-438"><a href="#cb25-438" aria-hidden="true" tabindex="-1"></a>                denominator <span class="op">=</span> np.<span class="bu">sum</span>(gamma[i, :])</span>
<span id="cb25-439"><a href="#cb25-439" aria-hidden="true" tabindex="-1"></a>                a[i, j] <span class="op">=</span> (numerator<span class="op">+</span>pseudocount) <span class="op">/</span> (denominator<span class="op">+</span>pseudocount) </span>
<span id="cb25-440"><a href="#cb25-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-441"><a href="#cb25-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-442"><a href="#cb25-442" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> np.zeros((N, M))</span>
<span id="cb25-443"><a href="#cb25-443" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(gamma.shape)</span></span>
<span id="cb25-444"><a href="#cb25-444" aria-hidden="true" tabindex="-1"></a>        gamma_sum <span class="op">=</span> np.<span class="bu">sum</span>(gamma, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb25-445"><a href="#cb25-445" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-446"><a href="#cb25-446" aria-hidden="true" tabindex="-1"></a>        obs <span class="op">=</span> []</span>
<span id="cb25-447"><a href="#cb25-447" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> sequence:</span>
<span id="cb25-448"><a href="#cb25-448" aria-hidden="true" tabindex="-1"></a>            obs.append(<span class="bu">int</span>(i))</span>
<span id="cb25-449"><a href="#cb25-449" aria-hidden="true" tabindex="-1"></a>        obs <span class="op">=</span> np.array(obs)</span>
<span id="cb25-450"><a href="#cb25-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-451"><a href="#cb25-451" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb25-452"><a href="#cb25-452" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(M):</span>
<span id="cb25-453"><a href="#cb25-453" aria-hidden="true" tabindex="-1"></a>                mask <span class="op">=</span> (obs<span class="op">==</span>k) <span class="co"># for indicative function i.e. 1 if observed = yt, else 0</span></span>
<span id="cb25-454"><a href="#cb25-454" aria-hidden="true" tabindex="-1"></a>                b[j, k] <span class="op">=</span> (np.<span class="bu">sum</span>(gamma[j]<span class="op">*</span>mask)<span class="op">+</span> pseudocount) <span class="op">/</span> (np.<span class="bu">sum</span>(gamma[j]) <span class="op">+</span> pseudocount) </span>
<span id="cb25-455"><a href="#cb25-455" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-456"><a href="#cb25-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-457"><a href="#cb25-457" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Normalize rows to ensure each row sums to 1.0</span></span>
<span id="cb25-458"><a href="#cb25-458" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> a <span class="op">/</span> np.<span class="bu">sum</span>(a, axis<span class="op">=</span><span class="dv">1</span>)[:, np.newaxis]</span>
<span id="cb25-459"><a href="#cb25-459" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> b <span class="op">/</span> np.<span class="bu">sum</span>(b, axis<span class="op">=</span><span class="dv">1</span>)[:, np.newaxis]</span>
<span id="cb25-460"><a href="#cb25-460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-461"><a href="#cb25-461" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"a = </span><span class="sc">{</span>a<span class="sc">}</span><span class="ss">, b = </span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-462"><a href="#cb25-462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-463"><a href="#cb25-463" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Log Likelihood Calculation</span></span>
<span id="cb25-464"><a href="#cb25-464" aria-hidden="true" tabindex="-1"></a>        log_likelihood <span class="op">=</span> np.<span class="bu">sum</span>(np.log(np.<span class="bu">sum</span>(alpha, axis<span class="op">=</span><span class="dv">0</span>)))</span>
<span id="cb25-465"><a href="#cb25-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-466"><a href="#cb25-466" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convergence Check</span></span>
<span id="cb25-467"><a href="#cb25-467" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.<span class="bu">abs</span>(log_likelihood <span class="op">-</span> prev_log_likelihood) <span class="op">&lt;</span> tol:</span>
<span id="cb25-468"><a href="#cb25-468" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Converged after </span><span class="sc">{</span>iteration <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss"> iterations."</span>)</span>
<span id="cb25-469"><a href="#cb25-469" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb25-470"><a href="#cb25-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-471"><a href="#cb25-471" aria-hidden="true" tabindex="-1"></a>        prev_log_likelihood <span class="op">=</span> log_likelihood</span>
<span id="cb25-472"><a href="#cb25-472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-473"><a href="#cb25-473" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a, b, pi</span>
<span id="cb25-474"><a href="#cb25-474" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-475"><a href="#cb25-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-476"><a href="#cb25-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-477"><a href="#cb25-477" aria-hidden="true" tabindex="-1"></a>The Viterbi algorithm is a dynamic programming algorithm used for decoding Hidden Markov Models (HMMs) and finding the most likely sequence of hidden states given an observed sequence. </span>
<span id="cb25-478"><a href="#cb25-478" aria-hidden="true" tabindex="-1"></a>The algorithm efficiently determines the optimal state sequence by considering the probabilities of transitions and emissions.</span>
<span id="cb25-479"><a href="#cb25-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-480"><a href="#cb25-480" aria-hidden="true" tabindex="-1"></a>The core idea behind the Viterbi algorithm is to iteratively compute the most likely path to each state at each time step, incorporating both the current observation and the previously calculated probabilities.</span>
<span id="cb25-481"><a href="#cb25-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-482"><a href="#cb25-482" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-483"><a href="#cb25-483" aria-hidden="true" tabindex="-1"></a>Î´_i(t) = max_j Î´_j(t - 1) a_ji b_i(Y_t)</span>
<span id="cb25-484"><a href="#cb25-484" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-485"><a href="#cb25-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-486"><a href="#cb25-486" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-487"><a href="#cb25-487" aria-hidden="true" tabindex="-1"></a>Ïˆ_i(t) = argmax_j Î´_j(t - 1) a_ji</span>
<span id="cb25-488"><a href="#cb25-488" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-489"><a href="#cb25-489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-492"><a href="#cb25-492" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-493"><a href="#cb25-493" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> predict(sequence, states, a, b, pi):</span>
<span id="cb25-494"><a href="#cb25-494" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Makes use of the viterbi algorithm to predict best path</span></span>
<span id="cb25-495"><a href="#cb25-495" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize Variables</span></span>
<span id="cb25-496"><a href="#cb25-496" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="bu">len</span>(sequence)</span>
<span id="cb25-497"><a href="#cb25-497" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(states)</span>
<span id="cb25-498"><a href="#cb25-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-499"><a href="#cb25-499" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Pseudocount to handle zeros</span></span>
<span id="cb25-500"><a href="#cb25-500" aria-hidden="true" tabindex="-1"></a>    pseudocount <span class="op">=</span> <span class="fl">1e-100</span></span>
<span id="cb25-501"><a href="#cb25-501" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-502"><a href="#cb25-502" aria-hidden="true" tabindex="-1"></a>    viterbi_table <span class="op">=</span> np.zeros((N, T)) <span class="co"># delta</span></span>
<span id="cb25-503"><a href="#cb25-503" aria-hidden="true" tabindex="-1"></a>    backpointer <span class="op">=</span> np.zeros((N, T)) <span class="co"># psi</span></span>
<span id="cb25-504"><a href="#cb25-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-505"><a href="#cb25-505" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialization step, for t = 0</span></span>
<span id="cb25-506"><a href="#cb25-506" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="bu">int</span>(sequence[<span class="dv">0</span>]))</span>
<span id="cb25-507"><a href="#cb25-507" aria-hidden="true" tabindex="-1"></a>    viterbi_table[:, <span class="dv">0</span>] <span class="op">=</span> pi <span class="op">*</span> b[:, <span class="bu">int</span>(sequence[<span class="dv">0</span>])] <span class="op">+</span> pseudocount</span>
<span id="cb25-508"><a href="#cb25-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-509"><a href="#cb25-509" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate Probabilities</span></span>
<span id="cb25-510"><a href="#cb25-510" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, T):</span>
<span id="cb25-511"><a href="#cb25-511" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> s <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb25-512"><a href="#cb25-512" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb25-513"><a href="#cb25-513" aria-hidden="true" tabindex="-1"></a>            max_prob <span class="op">=</span> <span class="bu">max</span>(viterbi_table[prev_s][t<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> a[prev_s][s] <span class="cf">for</span> prev_s <span class="kw">in</span> <span class="bu">range</span>(N)) <span class="op">*</span> b[s][<span class="bu">int</span>(sequence[t])] </span>
<span id="cb25-514"><a href="#cb25-514" aria-hidden="true" tabindex="-1"></a>            viterbi_table[s][t] <span class="op">=</span> max_prob <span class="op">+</span> pseudocount</span>
<span id="cb25-515"><a href="#cb25-515" aria-hidden="true" tabindex="-1"></a>            backpointer[s][t] <span class="op">=</span> np.argmax([viterbi_table[prev_s][t<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> a[prev_s][s]<span class="cf">for</span> prev_s <span class="kw">in</span> <span class="bu">range</span>(N)])</span>
<span id="cb25-516"><a href="#cb25-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-517"><a href="#cb25-517" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Traceback and Find Best Path</span></span>
<span id="cb25-518"><a href="#cb25-518" aria-hidden="true" tabindex="-1"></a>    best_path <span class="op">=</span> []</span>
<span id="cb25-519"><a href="#cb25-519" aria-hidden="true" tabindex="-1"></a>    last_state <span class="op">=</span> np.argmax(viterbi_table[:, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb25-520"><a href="#cb25-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-521"><a href="#cb25-521" aria-hidden="true" tabindex="-1"></a>    best_path.append(last_state)</span>
<span id="cb25-522"><a href="#cb25-522" aria-hidden="true" tabindex="-1"></a>    best_prob <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb25-523"><a href="#cb25-523" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(T<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb25-524"><a href="#cb25-524" aria-hidden="true" tabindex="-1"></a>        last_state <span class="op">=</span> last_state <span class="op">=</span> np.argmax(viterbi_table[:, t])</span>
<span id="cb25-525"><a href="#cb25-525" aria-hidden="true" tabindex="-1"></a>        best_prob <span class="op">*=</span> (viterbi_table[last_state, t] <span class="op">+</span> pseudocount)</span>
<span id="cb25-526"><a href="#cb25-526" aria-hidden="true" tabindex="-1"></a>        best_path.append(last_state) <span class="co"># i.e. add to start of list</span></span>
<span id="cb25-527"><a href="#cb25-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-528"><a href="#cb25-528" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-529"><a href="#cb25-529" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_path</span>
<span id="cb25-530"><a href="#cb25-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-531"><a href="#cb25-531" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>